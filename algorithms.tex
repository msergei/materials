\part{Алгоритмы}
		
	\section{Поиск}
		\subsection{Бинарный поиск (Binary search) \label{search:binary}}
		
		Бинарный поиск работает только с СОРТИРОВАННЫМ массивом. Похож на поиск в телефонной книге, когда необходимо найти человека с фамилией на букву К - справочник открывается в середине. Буква К оказывается либо в первой половине, либо во-второй таким образом алгоритм отбросил за 1 итерацию половину массива.
		Поиск продолжается в той половине где К находится и повторяется до тех пор пока не будет найдена буква.
		
		\subsubsection{Сложность}
\begin{table}[h!]
\caption{Время работы алгоритма Бинарного поиска в O-нотации}
\begin{tabular}{|l|l|l|}
\hline
Худший & Средний & Лучший \\ \hline
$ O(\log n) $ & $ O(\log n) $ & $ O(\log n) $ \\\hline
\end{tabular}
\end{table}

		\subsubsection{Реализация}
\linenumbers
\inputpython{binary-search.py}{1}{100}
\nolinenumbers	
		
	\section{Сортировка}
		\subsection{Сортировка выбором (Selection sort) \label{sort:select}}
		
		Сортировка выбором не самый эффективный алгоритм поиска, работает аналогично алгоритму "Сортировка пузырьком". 
		На входе алгоритма дан список элементов. Мы должны пройти по массиву столько раз, сколько элементов в нем находится. На каждой итерации выбирается максимальный элемент из текущего списка, удаляется из него и вставляется в новый список.
		
		\subsubsection{Сложность}
		
\begin{table}[h!]
\caption{Время работы алгоритма Сортировка выбором в O-нотации}
\begin{tabular}{|l|l|l|}
\hline
Худший & Средний & Лучший \\ \hline
$ O(n^{2}) $ & $ O(n^{2}) $ & $ O(n^{2}) $ \\\hline
\end{tabular}
\end{table}

		\subsubsection{Реализация}
		
\linenumbers
\inputpython{selection-sort.py}{1}{100}
\nolinenumbers	

		\subsection{Быстрая сортировка (Quick sort) \label{sort:quick}}
		Это один из самых быстрых алгоритмов! Является примером концепции \textbf{разделяй и властвуй} (см. \ref{idea:diff}) и примером реализации рекурсии (см. \ref{idea:recur}). Доказывается \textbf{индукционным методом}.
		
		Задание дан массив элементов, который нужно отсортировать. Например: 6, 3, 2, 9, 0, 1, 2, 5, 4.
		
		Для выполнения задачи необходимо реализовать базовый случай и \textbf{сокращение размера задачи}. 
		\begin{enumerate}
		\item Базовый случай представляет массив из одного элемента, при этом он и возвращается. Т.е. сортировать нечего.
		\item В случае, когда длина массива больше 2х необходимо выбрать опорный элемент. Его можно выбрать по-разному, но обычно лучшие показатели показывает алгоритм выбора случайного элемента. Далее все элементы сравниваются с текущим, те, которые меньше должны поместиться справа, те которые больше слева.
		
		$ [4 7 1 5 9 3] => quick-sort([4 1 3]) + [5] + quick-sort([7 9]) $
		Затем алгоритм quick-sort повторяется для правого и левого массивов в отдельности. Элементарно!
		\end{enumerate}

В таблице далее представлена временная сложность работы алгоритма:

		\subsubsection{Сложность}
\begin{table}[h!]
\caption{Время работы алгоритма Быстрой сортировки в O-нотации}
\begin{tabular}{|l|l|l|}
\hline
Худший & Средний & Лучший \\ \hline
$ O(n^{2}) $ & $ O(n*\log n) $ & $ O(n*\log n) $ \\\hline
\end{tabular}
\end{table}

\section{Сортировка слиянием (Merge sort)}

	\linenumbers
\inputpython{merge-sort.py}{1}{100}
\nolinenumbers
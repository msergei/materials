\part{Алгоритмы и структуры данных}

\chapter{Концепции}

\section{Разделяй и властвуй \label{idea:diff}}
\section{Не повторяйся (DRY) \label{idea:dry}}
\textbf{DRY} - \textbf{Do not repeat yourself} - \textbf{Не повторяйся} - концепция программирования при которой код пишется только один раз, для реализации этого принципа применяются различные методологии программирования, например, \textbf{ООП} (см. \ref{method:oop}), а так же функции и шаблоны (см. \ref{idea:pattern}).

\section{Рекурсия \label{idea:recur}}


\textbf{Рекурсия} - это абстракция, которая означает повторение какого-то действия с измененными входными данными. Применительно к теории алгоритмов, определяют рекурсивную функцию. 

\textbf{Рекурсивная функция} - это алгоритм, который вызывает сам себя, тем самым образуя стек вызовов, с измененными аргументами. Что бы функция не поучилась бесконечной, то определяют базовый случай, который завершает работу функции и всего стека вызовов.

В общем случае алгоритм функции состоит из двух условий:
\begin{enumerate}
\item Инструкции вызова этой же функции с передачей измененных аргументов;
\item Базовый случай, который завершает работу функции.
\end{enumerate}

Рекурсия не уменьшает время работы кода, она лишь может уменьшить время работы программиста! Отлично подходит под концепцию DRY. Пример реализации задача вычисления факториала (см. \ref{tasks:fac}), чисел Фибонначи (см \ref{tasks:fib}) и определение простых чисел (см. \ref{tasks:simple}). 

\section{Шаблон проектирования или паттерн \label{idea:pattern}}
\textbf{Шаблон проектирования} или \textbf{паттерн} (англ. \textbf{design pattern}) в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

\chapter{Методологии программирования}

\section{Объекто-ориентированное программирование (ООП) \label{method:oop} }
\section{Функциональное программирование\label{method:func}}
\section{Императивное программирование\label{method:imperat}}

\chapter{Структуры данных}

\section{Сводная таблица времени операций и затрат памяти}

\begin{table}[h!]
\caption{Сводная таблица сложности операций}
\begin{tabular}{|l|l|l|l|}
\hline
Тип операции / Структура & Чтение & Вставка & Удаление \\ \hline
Массивы 				 & O(1)   & O(n) 	& O(n)  \\ \hline
Списки 					 & O(n)   & O(1) 	& O(1) \\ \hline
\end{tabular}
\end{table}

Вставка и удаление происходит за время O(1) только в случае мгновенного доступа к элементу.

\section{Базовые структуры данных}
\subsection{Массив}

\textbf{Массив} - это базовая структура данных, такая, что все ячейки (элементарные) единицы это структуры располагаются в памяти последовательно. Каждая ячейка не хранит никакой информации о других элементах массива. Массив это самая "native" структура данных, именно она максимально просто реализуется в оперативной памяти.

\textbf{Выделение памяти} под массив означает найти n свободных ячеек памяти располагающихся последовательно. Где n - это размер массива. Т.к. выделение памяти под массив операция трудоемкая, то как правило происходит предвыделение памяти под него или резервирование, т.е. при создании массива выделяется памяти сразу в 2 раза больше, чем его длина. Следующая операция предвыделения может происходить при заполнении массива на 70\%.
При использовании массива хранится ссылка на расположение первого элемента, например, в двоичном виде: 4078912
Тогда как адрес 5ого элемента массива может быть путем сложения адреса 1ого элемента и индекса искомого. Т.е. 4078912 + 5. 

Основное назначение массива: возможность \textbf{произвольного доступа}, т.е. чтение за O(1). Подробнее о времени операций см. в таблице \ref{time:arr}.
Эта структура плохо подходит для изменения.

\subsubsection{Основные операции}

\begin{table}[h!]
\label{time:arr}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{2}{|l|}{\multirow{2}{*}{Тип операции}} & \multicolumn{3}{l|}{Временная сложность} & \multicolumn{3}{l|}{Затраты памяти} \\ \cline{3-8} 
\multicolumn{2}{|l|}{}                  & Худшая & Средняя & Лучшая & Худшая & Средняя & Лучшая		\\ \hline
\multirow{3}{*}{Вставка}     & Конец 	& O(n) 	 & O(n)    & O(1)   & O(n)   & O(n)    & O(1)		\\ \cline{2-8} 
             & Середина & O(n) 	 & O(n)    & O(n)   & O(n)   & O(n)    & O(n)		\\ \cline{2-8} 
             & Начало 	& O(n) 	 & O(n)    & O(1)   & O(n)   & O(n)    & O(1)		\\ \hline
\multirow{3}{*}{Удаление}    & Конец 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Середина & O(n) 	 & O(n)    & O(n)   & O(n)   & O(n)    & O(1)		\\ \cline{2-8} 
             & Начало 	& O(n) 	 & O(n)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
\multirow{3}{*}{Чтение}      & Конец 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Середина & O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
			
\end{tabular}
\end{table}

\subsection{Список}
\textbf{Список} - это базовая структура, которая является ссылочной. Каждая ячейка содержит ссылку на другую ячейку (т.е. каждый элемент является по сути отдельной структурой, у которого есть минимум 2 поля: 1.значение 2.ссылка на следующий элемент), такой список называют \textbf{односвязным}. При этом для обращения к этому списку в переменную сохраняется ссылку на голову (head) и обычно длину всего списка.

Если каждая ячейка содержит ссылку на 2 ячейки то такой список называют \textbf{двусвязным}. В этом случае в переменную сохраняется ссылка и на начало и на конечный элемент списка (tail). К каждому элементу списка добавляется еще одно поле: ссылка на предыдущий элемент. Эта структура данных отлично подходит для \textbf{последовательного доступа}.
Выделение памяти под такой список часто происходит динамически, т.е. увеличивается по мере увеличения списка, не происходит предвыделения (резервирования) памяти.
\subsubsection{Основные операции односвязного списка}
Односвязные список прекрасно подходит для реализации стека (LIFO) (см. \ref{struct:lifo}), а 2 односвязных списка подходят для реализации структуры типа очередь (см. \ref{struct:fifo}). 
\begin{table}[h!]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{2}{|l|}{\multirow{2}{*}{Тип операции}} & \multicolumn{3}{l|}{Временная сложность} & \multicolumn{3}{l|}{Затраты памяти} \\ \cline{3-8} 
\multicolumn{2}{|l|}{}                  & Худшая & Средняя & Лучшая & Худшая & Средняя & Лучшая		\\ \hline
\multirow{3}{*}{Вставка}     & Конец 	& O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
\multirow{3}{*}{Удаление}    & Конец 	& O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
\multirow{3}{*}{Чтение}      & Конец 	& O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
			
\end{tabular}
\end{table}

Так же иногда говорят, что вставка элемента перед заданым имеет временную сложность O(n).
\subsubsection{Основные операции двусвязного списка}
\begin{table}[h!]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{2}{|l|}{\multirow{2}{*}{Тип операции}} & \multicolumn{3}{l|}{Временная сложность} & \multicolumn{3}{l|}{Затраты памяти} \\ \cline{3-8} 
\multicolumn{2}{|l|}{}                  & Худшая & Средняя & Лучшая & Худшая & Средняя & Лучшая		\\ \hline
\multirow{3}{*}{Вставка}     & Конец 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
\multirow{3}{*}{Удаление}    & Конец 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
\multirow{3}{*}{Чтение}      & Конец 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
			
\end{tabular}
\end{table}

\section{Абстрактные структуры данных}
\subsection{Очередь (FIFO) \label{struct:fifo}}
\subsection{Стек (LIFO) \label{struct:lifo}}

\chapter{Алгоритмы}

\section{Поиск}
\subsection{Бинарный поиск (Binary search) \label{search:binary}}

Бинарный поиск работает только с СОРТИРОВАННЫМ массивом. Похож на поиск в телефонной книге, когда необходимо найти человека с фамилией на букву К - справочник открывается в середине. Буква К оказывается либо в первой половине, либо во-второй таким образом алгоритм отбросил за 1 итерацию половину массива.
Поиск продолжается в той половине где К находится и повторяется до тех пор пока не будет найдена буква.

\subsubsection{Сложность}
\begin{table}[h!]
\caption{Время работы алгоритма Бинарного поиска в O-нотации}
\begin{tabular}{|l|l|l|}
\hline
Худший & Средний & Лучший \\ \hline
$ O(\log n) $ & $ O(\log n) $ & $ O(\log n) $ \\\hline
\end{tabular}
\end{table}

\subsubsection{Реализация}
\linenumbers
\inputpython{binary-search.py}{1}{100}
\nolinenumbers	

\section{Сортировка}
\subsection{Сортировка выбором (Selection sort) \label{sort:select}}

Сортировка выбором не самый эффективный алгоритм поиска, работает аналогично алгоритму "Сортировка пузырьком". 
На входе алгоритма дан список элементов. Мы должны пройти по массиву столько раз, сколько элементов в нем находится. На каждой итерации выбирается максимальный элемент из текущего списка, удаляется из него и вставляется в новый список.

\subsubsection{Сложность}

\begin{table}[h!]
\caption{Время работы алгоритма Сортировка выбором в O-нотации}
\begin{tabular}{|l|l|l|}
\hline
Худший & Средний & Лучший \\ \hline
$ O(n^{2}) $ & $ O(n^{2}) $ & $ O(n^{2}) $ \\\hline
\end{tabular}
\end{table}

\subsubsection{Реализация}

\linenumbers
\inputpython{selection-sort.py}{1}{100}
\nolinenumbers	

\subsection{Быстрая сортировка (Quick sort) \label{sort:quick}}
Это один из самых быстрых алгоритмов! Является примером концепции \textbf{разделяй и властвуй} (см. \ref{idea:diff}) и примером реализации рекурсии (см. \ref{idea:recur}). Доказывается \textbf{индукционным методом}.

Задание дан массив элементов, который нужно отсортировать. Например: 6, 3, 2, 9, 0, 1, 2, 5, 4.

Для выполнения задачи необходимо реализовать базовый случай и \textbf{сокращение размера задачи}. 
\begin{enumerate}
\item Базовый случай представляет массив из одного элемента, при этом он и возвращается. Т.е. сортировать нечего.
\item В случае, когда длина массива больше 2х необходимо выбрать опорный элемент. Его можно выбрать по-разному, но обычно лучшие показатели показывает алгоритм выбора случайного элемента. Далее все элементы сравниваются с текущим, те, которые меньше должны поместиться справа, те которые больше слева.

$ [4 7 1 5 9 3] => quick-sort([4 1 3]) + [5] + quick-sort([7 9]) $
Затем алгоритм quick-sort повторяется для правого и левого массивов в отдельности. Элементарно!
\end{enumerate}

В таблице далее представлена временная сложность работы алгоритма:

\subsubsection{Сложность}
\begin{table}[h!]
\caption{Время работы алгоритма Быстрой сортировки в O-нотации}
\begin{tabular}{|l|l|l|}
\hline
Худший & Средний & Лучший \\ \hline
$ O(n^{2}) $ & $ O(n*\log n) $ & $ O(n*\log n) $ \\\hline
\end{tabular}
\end{table}

\section{Сортировка слиянием (Merge sort)}

\linenumbers
\inputpython{merge-sort.py}{1}{100}
\nolinenumbers

\chapter{Задачки}

\section{Вычисление факториала \label{tasks:fac}}
Задача имеет множество решений. По этой причине реализуем хотя бы несколько с проверкой ответа из библиотеки python..

\linenumbers
\inputpython{factorials.py}{1}{100}
\nolinenumbers

\section{Числа Фибоначчи \label{tasks:fib}}

\section{Определение простых чисел \label{tasks:simple} }

\linenumbers
\inputpython{simple-nums.py}{1}{100}
\nolinenumbers

\section{Найти наименьший общий делитель двух чисел (НОД)}
\textbf{Алгоритм Евклида}:
\begin{enumerate}
\item Большее число делим на меньшее.
\item Если делится без остатка, то меньшее число и есть НОД (следует выйти из цикла).
\item Если есть остаток, то большее число заменяем на остаток от деления.
\item Переходим к пункту 1.

\end{enumerate}

\section{Найти наибольшее общее кратное двух чисел (НОК)}

\section{Работа с датами}
\textbf{Задача:}

Дана таблица в базе данных SQL состоящая из колонок: имя трудяги, дата устройства на работу, дата увольнения\dots необходимо выбрать всех работников которые:
\begin{enumerate}
\item отработали в текущем месяце больше 20 дней
\item отработали за все время больше 30 дней
\item уволились меньше чем через 60 дней
\end{enumerate}

\textbf{Решение:}

\section{Шифр Цезаря}
Шифр Цезаря заключается в замене каждого символа входной строки на символ, находящийся на несколько позиций левее или правее его в алфавите.

Для всех символов сдвиг один и тот же. Сдвиг циклический, т.е. если к последнему символу алфавита применить единичный сдвиг, то он заменится на первый символ, и наоборот.

Напишите программу, которая шифрует текст шифром Цезаря.

Используемый алфавит − пробел и малые символы латинского алфавита: ' abcdefghijklmnopqrstuvwxyz'

\textbf{Формат ввода:}
На первой строке указывается используемый сдвиг шифрования: целое число. Положительное число соответствует сдвигу вправо. На второй строке указывается непустая фраза для шифрования. Ведущие и завершающие пробелы не учитывать.

\textbf{Формат вывода:}
Единственная строка, в которой записана фраза: Result: "..." , где вместо многоточия внутри кавычек записана зашифрованная последовательность.

\textbf{Примеры}

\begin{lstlisting}
Sample Input 1:
3
i am caesar
Sample Output 1:
Result: "lcdpcfdhvdu"
Sample Input 2:
-2
az
Sample Output 2:
Result: "zx"
Sample Input 3:
27
abc
Sample Output 3:
Result: "abc"
\end{lstlisting}

Решение:

\linenumbers
\inputpython{task1.py}{1}{100}
\nolinenumbers

\section{Парсинг лог файла}

\linenumbers
\inputpython{parse-log.py}{1}{100}
\nolinenumbers

\part{Data scince}

\section{Pandas}

\subsection{Основные команды}

\begin{enumerate}
\item Импорт \pyth{import pandas as pd}
\item Создание фрейма \pyth{frame == pd.DataFrame({'nums': range(10), 'chars': ['a']*10})}
\item Чтение из csv файла, headers - в какой строке имена заголовков столбцов \pyth{frame = pd.read_csv('dataset.tsv'. headers=0, sep='\t')}
\item Вывести имена столбцов \pyth{frame.columnm}
\item Добавление строки \pyth{frame = frame.append(new_line, ignore_index)}
\item Добавление столбца \pyth{frame['new_column_name'] = [Fasle]*5 + [True]*2}
\item Удаление строк \pyth{frame = frame.drop([5,6], axis=0)}
\item Удаление столбцов \pyth{frame = frame.drop('new_column_name', axis=1)}
\item Информация \pyth{fram.info()}
\item Сохранение в csv \pyth{frame.to_csv('my_file.csv', sep='', header=True, index=None)}
\item Вывод на экран \pyth{!cat my_file.csv}
\item Вывод типов столбцов \pyth{frame.dtypes}
\item Изменение типа стобца \pyth{frame.Birth = frame.apply(pd.to_datetime)}
\item Заполнить пропуски \pyth{frame.fillna('some_sting', inplace=True)}
\item Вывести один столбец \pyth{frame.Birth}
\item Размер фрейма в строках и столбцах \pyth{frame.shape}
\end{enumerate}

\subsection{Селекция}

\begin{enumerate}
\item Вывести 3 первых строки \pyth{frame.head(3)} \pyth{frame[:3]}
\item Вывести последние 3 строки \pyth{frame[-3:]}
\item Селективный вывод по именам \pyth{frame.loc[[1,3,5], ['Name', 'City']]}
\item Селективный вывод по номерам \pyth{frame.iloc[[1,3,5], [0, 2]]}
\item Селективный вывод по именам и номерам \pyth{frame.ix[]}
\item Фильтрация по дате рождения \pyth{frame[frame.Birth >= pd.datetime(1885,1,1)]}
\item Фильтрация и пересечение \pyth{frame[(frame.Birth >= pd.datetime(1998)) & (frame.City != 'Moscow')]}
\end{enumerate}

\section{NumPy, SciPy, Matplotlib}

\subsection{NumPy - Базовые функции}

Базовые массивы, матрицы, высокопроизводтельные массивы.

\begin{enumerate}
\item Импорт \pyth{import numpy as np}
\item Создание массив \pyth{x = [2,3,4,6]}
\item Срезы и селекция \pyth{y[1:3]} \pyth{y[[0, 2]]} \pyth{y[y > 3]}
\item Операции над каждым элементов \pyth{y * 5} \pyth{y ^ 2} \pyth{y - 2}
\item Многомерный массив \pyth{arr = np.array([[1,2,3], [4,5,6]])}
\item Срезы \pyth{arr[1][2]}
\item Случайные числа \pyth{np.random.rand()} Нормальное распределение слуучайных чисел 4Х5 шт \pyth{np.random.rand(4,5)}
\item Производительность np \pyth{%time np.arange(0, 1000)} Обычный рейндж \pyth{%timeit range(0, 1000)}
\item Интерполяция \pyth{from skipy import interpolate; f = interpolate.interpld(x, y, lind='linear')}
\end{enumerate}

\subsection{SkiPy - Базовые функции}

Оптимизация и всякие высокоуровневые функции

\begin{enumerate}
\item Импорт \pyth{from skipy import optimize} \pyth{from skipy import linalg}
\item Создание функции \pyth{f = lambda x: (x[0] - 3.2) ** 2 + (x[1] - 0.1) ** 2 + 3}
\item Минимизация на интервале \pyth{x_min = optimize.minimize(f, [5,5])}
\item Линейная алгребра, решение системы линейных уравненией \pyth{linalg.solve(np.array(), np.array())}
\item Сингулярное разложение \pyth{linalg.svd(np.array())}
\end{enumerate}

\subsection{Matplotlib - построение графиков}

\begin{enumerate}
\item Импорт \pyth{from matplotlib import pylab as plt}
\item Простейшее построение графика \pyth{plt.plot([1,2,3,4], [1,4,9,16]); plt.show()}
\item Построение кубической параболы \pyth{x = np.arange(-10, 10, 0.1); y = x **3; plt.plot(x, y); plt.show()}
\end{enumerate}

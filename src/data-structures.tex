\part{Структуры данных}
		\section{Сводная таблица времени операций и затрат памяти}
		
\begin{table}[h!]
\caption{Сводная таблица сложности операций}
\begin{tabular}{|l|l|l|l|}
\hline
Тип операции / Структура & Чтение & Вставка & Удаление \\ \hline
Массивы 				 & O(1)   & O(n) 	& O(n)  \\ \hline
Списки 					 & O(n)   & O(1) 	& O(1) \\ \hline
\end{tabular}
\end{table}

Вставка и удаление происходит за время O(1) только в случае мгновенного доступа к элементу.
	
		\section{Базовые структуры данных}
			\subsection{Массив}
		
			\textbf{Массив} - это базовая структура данных, такая, что все ячейки (элементарные) единицы это структуры располагаются в памяти последовательно. Каждая ячейка не хранит никакой информации о других элементах массива. Массив это самая "native" структура данных, именно она максимально просто реализуется в оперативной памяти.
			
			\textbf{Выделение памяти} под массив означает найти n свободных ячеек памяти располагающихся последовательно. Где n - это размер массива. Т.к. выделение памяти под массив операция трудоемкая, то как правило происходит предвыделение памяти под него или резервирование, т.е. при создании массива выделяется памяти сразу в 2 раза больше, чем его длина. Следующая операция предвыделения может происходить при заполнении массива на 70\%.
			При использовании массива хранится ссылка на расположение первого элемента, например, в двоичном виде: 4078912
			Тогда как адрес 5ого элемента массива может быть путем сложения адреса 1ого элемента и индекса искомого. Т.е. 4078912 + 5. 
			
			Основное назначение массива: возможность \textbf{произвольного доступа}, т.е. чтение за O(1). Подробнее о времени операций см. в таблице \ref{time:arr}.
			Эта структура плохо подходит для изменения.
			
			\subsubsection{Основные операции}
			
\begin{table}[h!]
\label{time:arr}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{2}{|l|}{\multirow{2}{*}{Тип операции}} & \multicolumn{3}{l|}{Временная сложность} & \multicolumn{3}{l|}{Затраты памяти} \\ \cline{3-8} 
\multicolumn{2}{|l|}{}                  & Худшая & Средняя & Лучшая & Худшая & Средняя & Лучшая		\\ \hline
\multirow{3}{*}{Вставка}     & Конец 	& O(n) 	 & O(n)    & O(1)   & O(n)   & O(n)    & O(1)		\\ \cline{2-8} 
                             & Середина & O(n) 	 & O(n)    & O(n)   & O(n)   & O(n)    & O(n)		\\ \cline{2-8} 
                             & Начало 	& O(n) 	 & O(n)    & O(1)   & O(n)   & O(n)    & O(1)		\\ \hline
\multirow{3}{*}{Удаление}    & Конец 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Середина & O(n) 	 & O(n)    & O(n)   & O(n)   & O(n)    & O(1)		\\ \cline{2-8} 
                             & Начало 	& O(n) 	 & O(n)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
\multirow{3}{*}{Чтение}      & Конец 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Середина & O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
							
\end{tabular}
\end{table}
		
		\subsection{Список}
		\textbf{Список} - это базовая структура, которая является ссылочной. Каждая ячейка содержит ссылку на другую ячейку (т.е. каждый элемент является по сути отдельной структурой, у которого есть минимум 2 поля: 1.значение 2.ссылка на следующий элемент), такой список называют \textbf{односвязным}. При этом для обращения к этому списку в переменную сохраняется ссылку на голову (head) и обычно длину всего списка.
		
		Если каждая ячейка содержит ссылку на 2 ячейки то такой список называют \textbf{двусвязным}. В этом случае в переменную сохраняется ссылка и на начало и на конечный элемент списка (tail). К каждому элементу списка добавляется еще одно поле: ссылка на предыдущий элемент. Эта структура данных отлично подходит для \textbf{последовательного доступа}.
		Выделение памяти под такой список часто происходит динамически, т.е. увеличивается по мере увеличения списка, не происходит предвыделения (резервирования) памяти.
			\subsubsection{Основные операции односвязного списка}
			Односвязные список прекрасно подходит для реализации стека (LIFO) (см. \ref{struct:lifo}), а 2 односвязных списка подходят для реализации структуры типа очередь (см. \ref{struct:fifo}). 
\begin{table}[h!]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{2}{|l|}{\multirow{2}{*}{Тип операции}} & \multicolumn{3}{l|}{Временная сложность} & \multicolumn{3}{l|}{Затраты памяти} \\ \cline{3-8} 
\multicolumn{2}{|l|}{}                  & Худшая & Средняя & Лучшая & Худшая & Средняя & Лучшая		\\ \hline
\multirow{3}{*}{Вставка}     & Конец 	& O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
\multirow{3}{*}{Удаление}    & Конец 	& O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
\multirow{3}{*}{Чтение}      & Конец 	& O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
							
\end{tabular}
\end{table}

Так же иногда говорят, что вставка элемента перед заданым имеет временную сложность O(n).
			\subsubsection{Основные операции двусвязного списка}
\begin{table}[h!]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{2}{|l|}{\multirow{2}{*}{Тип операции}} & \multicolumn{3}{l|}{Временная сложность} & \multicolumn{3}{l|}{Затраты памяти} \\ \cline{3-8} 
\multicolumn{2}{|l|}{}                  & Худшая & Средняя & Лучшая & Худшая & Средняя & Лучшая		\\ \hline
\multirow{3}{*}{Вставка}     & Конец 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
\multirow{3}{*}{Удаление}    & Конец 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
\multirow{3}{*}{Чтение}      & Конец 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Середина & O(n) 	 & O(n)    & O(n)   & O(1)   & O(1)    & O(1)		\\ \cline{2-8} 
                             & Начало 	& O(1) 	 & O(1)    & O(1)   & O(1)   & O(1)    & O(1)		\\ \hline
							
\end{tabular}
\end{table}

	\section{Абстрактные структуры данных}
		\subsection{Очередь (FIFO) \label{struct:fifo}}
		\subsection{Стек (LIFO) \label{struct:lifo}}
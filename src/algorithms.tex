\part{Алгоритмы}

\chapter{Поиск}
		
\section{Бинарный поиск (Binary search) \label{search:binary}}

Бинарный поиск работает только с СОРТИРОВАННЫМ массивом. Похож на поиск в телефонной книге, когда необходимо найти человека с фамилией на букву К - справочник открывается в середине. Буква К оказывается либо в первой половине, либо во-второй таким образом алгоритм отбросил за 1 итерацию половину массива.
Поиск продолжается в той половине где К находится и повторяется до тех пор пока не будет найдена буква.

\subsubsection{Сложность}
\begin{table}[h!]
\caption{Время работы алгоритма Бинарного поиска в O-нотации}
\begin{tabular}{|l|l|l|}
\hline
Худший & Средний & Лучший \\ \hline
$ O(\log n) $ & $ O(\log n) $ & $ O(\log n) $ \\\hline
\end{tabular}
\end{table}

		\subsubsection{Реализация}
\linenumbers
\inputpython{binary-search.py}{1}{100}
\nolinenumbers	
		
	\section{Сортировка}
		\subsection{Сортировка выбором (Selection sort) \label{sort:select}}
		
		Сортировка выбором не самый эффективный алгоритм поиска, работает аналогично алгоритму "Сортировка пузырьком". 
		На входе алгоритма дан список элементов. Мы должны пройти по массиву столько раз, сколько элементов в нем находится. На каждой итерации выбирается максимальный элемент из текущего списка, удаляется из него и вставляется в новый список.
		
		\subsubsection{Сложность}
		
\begin{table}[h!]
\caption{Время работы алгоритма Сортировка выбором в O-нотации}
\begin{tabular}{|l|l|l|}
\hline
Худший & Средний & Лучший \\ \hline
$ O(n^{2}) $ & $ O(n^{2}) $ & $ O(n^{2}) $ \\\hline
\end{tabular}
\end{table}

		\subsubsection{Реализация}
		
\linenumbers
\inputpython{selection-sort.py}{1}{100}
\nolinenumbers	

		\subsection{Быстрая сортировка (Quick sort) \label{sort:quick}}
		Это один из самых быстрых алгоритмов! Является примером концепции \textbf{разделяй и властвуй} (см. \ref{idea:diff}) и примером реализации рекурсии (см. \ref{idea:recur}). Доказывается \textbf{индукционным методом}.
		
		Задание дан массив элементов, который нужно отсортировать. Например: 6, 3, 2, 9, 0, 1, 2, 5, 4.
		
		Для выполнения задачи необходимо реализовать базовый случай и \textbf{сокращение размера задачи}. 
		\begin{enumerate}
		\item Базовый случай представляет массив из одного элемента, при этом он и возвращается. Т.е. сортировать нечего.
		\item В случае, когда длина массива больше 2х необходимо выбрать опорный элемент. Его можно выбрать по-разному, но обычно лучшие показатели показывает алгоритм выбора случайного элемента. Далее все элементы сравниваются с текущим, те, которые меньше должны поместиться справа, те которые больше слева.
		
		$ [4 7 1 5 9 3] => quick-sort([4 1 3]) + [5] + quick-sort([7 9]) $
		Затем алгоритм quick-sort повторяется для правого и левого массивов в отдельности. Элементарно!
		\end{enumerate}

В таблице далее представлена временная сложность работы алгоритма:

		\subsubsection{Сложность}
\begin{table}[h!]
\caption{Время работы алгоритма Быстрой сортировки в O-нотации}
\begin{tabular}{|l|l|l|}
\hline
Худший & Средний & Лучший \\ \hline
$ O(n^{2}) $ & $ O(n*\log n) $ & $ O(n*\log n) $ \\\hline
\end{tabular}
\end{table}

\section{Сортировка слиянием (Merge sort)}

\linenumbers
\inputpython{merge-sort.py}{1}{100}
\nolinenumbers

\chapter{Кеширование}

В информатике под алгоритмами кэширования (часто называемыми алгоритмами вытеснения или политиками вытеснения, а также «алгоритмами/политиками замещения») понимают оптимизацию инструкций — алгоритмы — особая компьютерная программа или аппаратно поддерживаемая структура, способная управлять кэшем информации, хранимой в компьютере. Когда кэш заполнен, алгоритм должен выбрать, что именно нужно удалить из него, чтобы иметь возможность записи (в кэш) новой, более актуальной информации.

«Уровень попаданий» кэша означает то, насколько часто искомые данные обнаруживаются в кэше. Более эффективные политики вытеснения отслеживают обращения к наиболее используемой информации, чтобы улучшить уровень попаданий (при том же размере кэша).

«Латентность» кэша означает, насколько быстро кэш может вернуть запрошенные данные непосредственно после запроса (в случае, если происходит «попадание»). Более быстрые стратегии вытеснения обычно отслеживают наименее используемую информацию — или, в случае кэша прямого отображения (direct-mapped cache), отсутствие информации, чтобы снизить затраты времени на обновление информации.

Каждая стратегия вытеснения является компромиссом между уровнем попаданий и латентностью. 

\section{Что такое когерентность кэша}
свойство кэшей, означающее целостность данных, хранящихся в локальных кэшах для разделяемого ресурса. Когерентность кэшей — частный случай когерентности памяти. 

\section{Алгоритм Белади}
\section{Least recently used (Вытеснение давно неиспользуемых)}
\section{Most Recently Used (Наиболее недавно использовавшийся)}
\section{ Псевдо-LRU}
\section{Сегментированный LRU}
\section{2-Way Set Associative (2-канальная ассоциативность)}
\section{Кэш прямого отображения (Direct-mapped cache)}
\section{Least-Frequently Used (Наименее часто используемый)}
\section{ Adaptive Replacement Cache (Адаптивная замена)}
\section{Multi Queue Caching Algorithm (Алгоритм многопоточного кэширования)}
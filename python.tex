\part{Вокруг python}

\begin{itemize}
    \item В python жесткая (сильная) типизация, но динамическая (утиная), не явная;
    \item Все переменные - ссылки на объекты;
    \item Контейнер - объект содержащий ссылки на другие объекты;
    \item Объект - любая сущность в python;
    \item Класс - объединение данных в какую-либо сущность;
    \item Свойства объекта:
    \begin{enumerate}
        \item Идентичность (id, т.е. \№ ячейки памяти);
        \item Тип - условная запись разрешенных операций над объектом;
        \item Значение.
    \end{enumerate}
    \item Выполнение кода python:
    \begin{enumerate}
        \item Компиляция в байт-код;
        \item Сохранение в .pyc;
        \item Выполнение байт-кода интерпретатором.
    \end{enumerate}
    \item Последовательность - упорядоченный набор объектов к элементам которого можно обратиться.
\end{itemize}

\section{Типы данных}

	К стандартным типам данных в Python относят:
	\begin{itemize}
		\item Числа: целые (int), вещественные (float), комплексные (complex);
		\item Байты (bytes и bytearray);
		\item Множества (set и frozenset);
		\item Кортежи (tuple) и Списки (list);
		\item Строки (str);
		\item Исключения (exceptions);
		\item None.
	\end{itemize}
	
\subsection{Разница между списками и котежами, когда используются}

	Списки в Python - упорядоченные изменяемые коллекции объектов произвольных типов.  
Кортеж — это неизменяемый список. С момента создания кортеж не может быть изменен никакими способами.  Кортеж определяется так же, как и список, но элементы перечисляются в круглых скобках вместо квадратных.
	\begin{itemize}
\item	Как и в списках, элементы в кортежах имеют определенный порядок. Точно так же нумерация элементов начинается с нуля. 
\item	Как и для списков, отрицательные индексы позволяют вести отсчет элементов с конца кортежа.
\item	К кортежам, как и к спискам можно применить операцию среза. Обратите внимание, что срез списка — новый список, а срез кортежа — новый кортеж.
\item	Работа с кортежами быстрее, чем со списками. Если вы определяете постоянный набор значений, и все, что вы хотите с ним когда-либо делать, это перебирать его элементы, используйте кортеж вместо списка.
\item	Кортеж может быть преобразован в список и наоборот.
	\end{itemize}
	
\subsection{Сделать свапинг 2х переменных}	

Сделать свапинг 2х переменных
	\begin{python}
		x=1
		y=2
		x,y=y,x
	\end{python}
	
\subsection{Mutable (изменяемые) и unmutable типы}

Все типы данных в Python относятся к одной из 2-х категорий: изменяемые (mutable) и неизменяемые (unmutable)( immutable). Многие из предопределённых типов данных Python — это типы неизменяемых объектов: числовые данные (int, float, complex), символьные строки (class 'str'), кортежи (tuple). Другие типы определены как изменяемые: списки (list), множества (set), словари (dict). Вновь определяемые пользователем типы (классы) могут быть определены как неизменяемые или изменяемые. Изменяемость объектов определённого типа является принципиально важной характеристикой, определяющей, может ли объект такого типа выступать в качестве ключа для словарей (dict) или нет.
Immutable типы в Python — это числа(numbers), строки (strings) и кортежи (tuples).	

\subsection{1 == 1.0 == True}

\subsection{Иерархия exceptions}

BaseExcaption делиться на 2 основных вида: системные и пользовательские исключения.

Пользовательские (Exception) - это нехватка памяти, ошибка атрибутов и индексов, ошибки сокетов.
Системные - это KeyboardError, SystemExit, GeneratorExit 

\subsubsection{Как вызвать исключение?}

\pyth{raise SomeException('Message error info')}


\section{Функции}

\begin{itemize}
    \item Инлайновые функции - lambda функции;
    \item Внутренние (вложенные) функции - функции определенные внутри других функций;
    \item Аргументы функций: порядковые (args) и именованные (kwargs).
\end{itemize}

\subsection{Области видимости контекста}

\subsection{Способы форматирования строк}

\subsubsection{Классический \%}

\begin{python}
var = 'world'
'Hello, %s' % var.upper()
# Hello, WORLD 
\end{python}

\subsubsection{Современный format()}

\begin{python}
var = 'world'
'Hello, {}'.foramt(var.upper())
# Hello, WORLD 
\end{python}

\subsubsection{Интерполяция литеральных строк python3.6+ (форматированные строковые литералы)}

\begin{python}
var = 'world'
f'Hello, {var.upper()}'
# Hello, WORLD
a, b = 4, 6
f'Result {a + b}'
# Result 10
\end{python}

\subsubsection{Шаблонные строки}

\begin{python}
from string import Template
var = 'Bob'
t = Template('Hey, \$name!')
t.substitute(name=var)
\end{python}

\subsection{Дается строка, разрезать по разделителю}

	Дается строка, разрезать по разделителю. Почтитать про операции со строками
	
	\begin{itemize}
	
		\item Базовые операции
		Конкатенация (сложение) S1 + S2, Дублирование строки 'spam' * 3, Длина строки (функция len), Доступ по индексу S[0], Извлечение среза s[3:5], Кроме того, можно задать шаг, с которым нужно извлекать срез s[3:5:1]. 
		\item S.split(символ)	Разбиение строки по разделителю
		\item S.find(str, [start],[end])	Поиск подстроки в строке. Возвращает номер первого вхождения или -1
		\item S.join(список)	Сборка строки из списка с разделителем S
		\item S.center(width, [fill])	Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)
		\item S.strip([chars])	Удаление пробельных символов в начале и в конце строки
		\item Форматирование строк с помощью метода format:
		\begin{python}
			>>> '{0}, {1}, {2}'.format('a', 'b', 'c')
			'a, b, c'
		\end{python}
	\end{itemize}
	
\subsection{min(), max(), sorted()}

	min() max()

		В языке программирования Python есть встроенные функции поиска минимума и максимума. Им можно передавать как один объект (список или другой объект-последовательность или итерируемый объект), так и непосредственно множество однотипных объектов. Если передается один список, то в нем находится минимум или максимум, который возвращается.
	\begin{python}
		>>> a = [45, 56, 12] 
		>>> min(a) 
		12 
	\end{python}
	\begin{itemize}
			
		\item Если передается несколько списков, то возвращается целый список. При этом сравнение происходит поэлементно: сначала сравниваются первые элементы списков. Если они не равны, то функция min вернет тот список, первый элемент которого меньше (max наоборот). Если первые элементы равны, то будут сравниваться вторые и т. д.
		\begin{python}
>>> b = [89, 0, 11] 
>>> min(a,b) 
45, 56, 12
		\end{python}
		\item В функциях min и max можно указать необязательный именной параметр key. Ему присваивается одноаргументная функция, которая выполняет какое-то предварительное действие над элементами, например, списка.
		\item Однако нельзя передать или смешанный список.	
	\end{itemize}

\subsection{Срезы в контейнерах}

\section{Средства языка}

\subsection{Соглашение о подчеркиваниях}

В python отсутствует механизм инкапсулирования методов, по этому есть только соглашения об использовании.

\subsubsection{\_var, \_method}

Одинарный префикс - подсказка, что переменная/метод предназначается для внутреннего использования, определенная в PEP8. Аналог защищенных (приватных) атрибутов с C++.

\begin{python}
class Test:
    def __init__(self):
        # Define class instance vars:
        self.foo = 11 
        self._bar = 23

t = Test()
t.foo
# >>> 11
t._bar
# >>> 23
\end{python}

Однако при импортировании всех методов из модуля (с помощью символа *), то методы начинающиеся с нижнего \_ импортированны не будут, только если не определены в \_\_all\_\_.

\subsubsection{var\_}

Замыкающий одинарный символ подчеркивания используется для избежания совпадения со встроенными зарезервированными словами.

\subsubsection{\_\_var}

Аналог защищенных (protected) атрибутов из C++. Двойное подчеркивание заставляет интерпретатор Python переписать имя атрибута, что того, что бы избежать конфликтов из-за совпадения имен. Такое переписывание - искажение имени (name manling).

\begin{python}
class Test2:
    def __init__(self):
        # Define class instance vars:
        self.foo = 11 
        self._bar = 23
        self.__baz = 41

t = Test()
t.foo
# >>> 11
t._bar
# >>> 23
t.__baz
# AttributeError
t._Test2__baz
# >>> 41
\end{python}

Двойное подчеркивание - дандер (double underscrore).

\subsubsection{\_\_var\_\_}

Зарезервированные методы, обычно называтся, как магические методы.

\subsection{Декоратор, лексическое замыкание}

Декоратор - это синтетический сахар, конструкция-обертка, позволяющая изменить работу функции без ее изменения. Является шаблоном проектирования. Основан на лексическом замыкании.

Лексическое замыкание или замыкание - запоминает значения из своего лексического контекста, даже когда поток управления программы уже не находится в нем. 

\subsubsection{Фабрика декораторов}

\subsubsection{Декоратор класса}

\subsection{Магические методы}	

то специальные методы, с помощью которых вы можете добавить в ваши классы «магию». Они всегда обрамлены двумя нижними подчеркиваниями (например, \pyth{__init__} или \pyth{__lt__}). 

сем известен самый базовый магический метод, \pyth{__init__}. С его помощью мы можем инициализировать объект. Однако, когда я пишу x = SomeClass(), \pyth{__init__} не самое первое, что вызывается. На самом деле, экземпляр объекта создаёт метод \pyth{__new__}, а затем аргументы передаются в инициализатор. На другом конце жизненного цикла объекта находится метод \pyth{__del__}. Давайте подробнее рассмотрим эти три магических метода:

\begin{itemize}
	\item \pyth{__new__(cls, [...)}
Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы, которые будут переданы в \pyth{__init__}. \pyth{__new__} используется весьма редко, но иногда бывает полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка. Я не намерен очень детально останавливаться на \pyth{__new__}, так как он не то чтобы очень часто нужен, но этот метод очень хорошо и детально описан в документации.

	\item \pyth{__init__(self, [...)}
Инициализатор класса. Ему передаётся всё, с чем был вызван первоначальный конструктор (так, например, если мы вызываем \pyth{x = SomeClass(10, 'foo')}, \pyth{__init__} получит 10 и 'foo' в качестве аргументов. \pyth{__init__} почти повсеместно используется при определении классов.

	\item \pyth{__del__(self)}
Если \pyth{__new__} и \pyth{__init__} образуют конструктор объекта, \pyth{__del__} это его деструктор. Он не определяет поведение для выражения \pyth{del x} (поэтому этот код не эквивалентен \pyth{x.__del__()}). Скорее, он определяет поведение объекта в то время, когда объект попадает в сборщик мусора. Это может быть довольно удобно для объектов, которые могут требовать дополнительных чисток во время удаления, таких как сокеты или файловыве объекты. Однако, нужно быть осторожным, так как нет гарантии, что \pyth{__del__} будет вызван, если объект продолжает жить, когда интерпретатор завершает работу. Поэтому \pyth{__del__} не может служить заменой для хороших программистских практик (всегда завершать соединение, если закончил с ним работать и тому подобное). Фактически, из-за отсутствия гарантии вызова, \pyth{__del__} не должен использоваться почти никогда; используйте его с осторожностью!

\end{itemize}

Одно из больших преимуществ использования магических методов в Питоне то, что они предоставляют простой способ заставить объекты вести себя по подобию встроенных типов. 

\section{Итераторы, генераторы. Yield}

Для понимания, что делает yield, необходимо понимать, что такое генераторы. Генераторам же предшествуют итераторы. Когда вы создаёте список, вы можете считывать его элементы один за другим — это называется итерацией:

\begin{python}
>>> mylist = [1, 2, 3]
>>> for i in mylist :
...    print(i)
1
2
3
\end{python}

Mylist является итерируемым объектом. Когда вы создаёте список, используя генераторное выражение, вы создаёте также итератор:

\begin{python}
>>> mylist = [x*x for x in range(3)]
>>> for i in mylist :
...    print(i)
0
1
4
\end{python}

Всё, к чему можно применить конструкцию «for… in...», является итерируемым объектом: списки, строки, файлы… Это удобно, потому что можно считывать из них значения сколько потребуется — однако все значения хранятся в памяти, а это не всегда желательно, если у вас много значений.

\textit{Генераторы}

Генераторы это тоже итерируемые объекты, но прочитать их можно лишь один раз. Это связано с тем, что они не хранят значения в памяти, а генерируют их на лету:

\begin{python}
>>> mygenerator = (x*x for x in range(3))
>>> for i in mygenerator :
...    print(i)
0
1
4
\end{python}

Всё то же самое, разве что используются круглые скобки вместо квадратных. НО: нельзя применить конструкцию for i in mygenerator второй раз, так как генератор может быть использован только единожды: он вычисляет 0, потом забывает про него и вычисляет 1, завершаяя вычислением 4 — одно за другим.

\textit{Yield}

Yield это ключевое слово, которое используется примерно как return — отличие в том, что функция вернёт генератор.

\begin{python}
>>> def createGenerator() :
...    mylist = range(3)
...    for i in mylist :
...        yield i*i
...
>>> mygenerator = createGenerator() # create generator
>>> print(mygenerator) # mygenerator is object!
<generator object createGenerator at 0xb7555c34>
>>> for i in mygenerator:
...     print(i)
0
1
4
\end{python}

В данном случае пример бесполезный, но это удобно, если вы знаете, что функция вернёт большой набор значений, который надо будет прочитать только один раз.
Чтобы освоить yield, вы должны понимать, что когда вы вызываете функцию, код внутри тела функции не исполняется. Функция только возвращает объект-генератор — немного мудрёно :-)
Ваш код будет вызываться каждый раз, когда for обращается к генератору.
В первый запуск вашей функции, она будет исполняться от начала до того момента, когда она наткнётся на yield — тогда она вернёт первое значение из цикла. На каждый следующий вызов будет происходить ещё одна итерация написанного вами цикла, возвращаться будет следующее значение — и так пока значения не кончатся.
Генератор считается пустым, как только при исполнении кода функции не встречается yield. Это может случиться из-за конца цикла, или же если не выполняется какое-то из условий «if/else».

\textit{Итератор} — это объект-абстракция, который позволяет брать из источника, будь это stdin или, скажем, какой-то большой контейнер, элемент за элементом, при этом итератор знает только о том объекте, на котором он в текущий момент остановился.
В Python (и не только в нем) есть два понятия, которые звучат практически одинаково, но обозначают разные вещи, — iterator и iterable. Первое — это объект, который реализует описанный выше интерфейс, а второе — контейнер, который может служить источником данных для итератора.
Если простым языком, генераторное выражение — это еще один синтаксический сахар в Python, простейший способ создать объект с интерфейсом итератора, при этом не загружая всех элементов в память (а это чаще всего и не нужно).
Основная фишка генератора в том, что он, подобно итератору, запоминает последний момент, когда к нему обращались, но при этом оперирует не абстрактными элементами, а вполне конкретными блоками кода. То есть если итератор по умолчанию будет перебирать элементы в контейнере, пока они не кончатся, то генератор будет гонять код, пока не выполнится какое-нибудь конкретное условие возврата. 

\textit{итератор:}
\begin{python}
class SimpleIterator(object):
 2     
 3     def __init__(self,fname):
 4         self.fd = open(fname,'r')
 5         
 6     def __iter__(self):
 7         return self
 8 
 9     def next(self):
10         l = self.fd.readline()
11         if l != '':
12             l = l.rstrip('\n')
13             num = int(l)
14             return num*2
15         raise StopIteration
\end{python}

\textit{генератор:}
\begin{python}
1 def power(start):
2     print "power is called the first time"
3     for i in xrange(start,start+5):
4         yield i*i
5     print "power is called the last time"
\end{python}

\subsection{lambda или анонимные функции}		

Анонимные функции не имеют имени и состоят из единственного выражения, значение которого является возвращаемым значением функции. Анонимные функции создаются с помощью ключевого слова lambda и используется в виде: lambda <аргументы>: <выражение> . Их удобно использовать для создания небольших функций. Анонимные функции являются выражением, в отличие от инструкции def. Вследствие этой особенности, lambda-выражения можно использовать в тех участках кода, где нельзя использовать def. Анонимные функции можно присваивать переменным.

Анонимные функции создаются с помощью инструкции lambda. Кроме этого, их не обязательно присваивать переменной, как делали мы инструкцией def func():
\begin{python}
>>>
>>> func = lambda x, y: x + y
>>> func(1, 2)
3
>>> func('a', 'b')
'ab'
>>> (lambda x, y: x + y)(1, 2)
3
>>> (lambda x, y: x + y)('a', 'b')
'ab'
>>>
>>> func = lambda *args: args
>>> func(1, 2, 3, 4)
(1, 2, 3, 4)
>>> a=[lambda x:x, lambda x:2*x]
>>> for i in a: print i(2)
... 
2
4
>>> func=lambda a,b:a+b
>>> func(1,2)
3	
\end{python}

\section{Классы}

Переменные бывают:
\begin{itemize}
    \item Переменные класса;
    \begin{python}
    class Test:
        var = 123
    \end{python}
    \item Переменные экземпляра.
    \begin{python}
    class Test:
        def __init__(self):
            self.var = 123
    \end{python}
\end{itemize}

\subsection{Типы атрибутов}

\begin{table}[h!]
\begin{tabular}{|l|l|l|}
\hline
Тип             & Доступен снаружи & Доступен из наследников \\ \hline
Открытый        & Да               & Да                      \\ \hline
Защищенный (\_) & Нет              & Да                      \\ \hline
Закрытый (\_\_) & Нет              & Нет                     \\ \hline
\end{tabular}
\end{table}

\subsection{В каком атрибуте находятся названия атрибутов?}

Получить \pyth{__dir__} можно вызывав его \pyth{object.__dir__} или через функцию \pyth{dir(object)}.

\subsection{Методы}

\subsubsection{Методы}

Функции и методы в Python — это практически одно и то же, за исключением того, что методы всегда ожидают первым параметром ссылку на сам объект (self). Это значит, что мы можем создавать декораторы для методов точно так же, как и для функций, просто не забывая про self (self - это соглашение об именовании перменной).

\begin{python}
class MyClass(object):
    def mymethod(self, x):
        return x == self._x
\end{python}

\subsubsection{Статический метод}

Статические методы - являются синтаксическими аналогами статических функций в основных языках программирования. Они не получают ни экземпляр (self), ни класс (cls) первым параметром. Для создания статического метода (только «новые» классы могут иметь статические методы) используется декоратор staticmethod

\begin{python}
>>> class D(object):  
       @staticmethod
       def test(x):
           return x == 0
...
>>> D.test(1)    # access to static method from class
False
>>> f = D()
>>> f.test(0)    # access to static method from insance of class
True

\end{python}

\subsubsection{Метод класса}

Метод класса - занимают промежуточное положение между статическими и обычными. В то время как обычные методы получают первым параметром экземпляр класса, а статические не получают ничего, в классовые методы передается класс. Возможность создания классовых методов является одним из следствий того, что в Python классы также являются объектами. Для создания классового (только «новые» классы могут иметь классовые методы) метода можно использовать декоратор classmethod

\begin{python}
>>> class A(object):  
      def __init__(self, int_val):
          self.val = int_val + 1
      @classmethod
      def fromString(cls, val):   # instead "self" we use "cls"
          return cls(int(val))
...
>>> class B(A):pass
...
>>> x = A.fromString("1")
>>> print x.__class__.__name__
A
>>> x = B.fromString("1")
>>> print x.__class__.__name__
B	
\end{python}

\subsection{\_\_slots\_\_}

Слоты служат конкретной цели - уменьшении потребления памяти.

Как пишет Guido в своей истории python о том, как изобретались new-style classes:
	Я боялся что изменения в системе классов плохо повлияют на производительность. В частности, чтобы дескрипторы данных работали корректно, все манипуляции атрибутами объекта начинались с проверки \pyth{__dict__} класса на то, что этот атрибут является дескриптором данных…
	
	На случай, если пользователи разочаруются ухудшением производительности, заботливые разработчики python придумали \pyth{__slots__}.
	Наличие \pyth{__slots__} ограничивает возможные имена атрибутов объекта теми, которые там указаны. Также, так как все имена атрибутов теперь заранее известны, снимает необходимость создавать \pyth{__dict__} экземпляра.
	К тому же, использование \pyth{__slots__} действительно может увеличить производительность, особенно уменьшив количество используемой памяти при создании множества небольших объектов.
	
	\begin{python}
class Slotter:
    __slots__ = ["a", "b"]

s = Slotter()
s.__dict__      # AttributeError
s.c = 1         # AttributeError
s.a = 1
s.a             # 1
s.b = 1
s.b             # 1
	\end{python}

\subsection{Методы \_\_repr\_\_ и \_\_str\_\_}

Нужны для печати/сериализвации собственных классов...
	
\subsection{MRO}

Порядок разрешения методов (method resolution order) позволяет Питону выяснить, из какого класса-предка нужно вызывать метод, если он не обнаружен непосредственно в классе-потомке. 

\begin{itemize}
\item staticmethod
\item classmethod
\end{itemize}

\section{Асинхронное программиорвание}

\subsection{Мультипроцессинг и threading}

Мультипроцессинг и threading

В Python есть модуль threading, и в нем есть все, что нужно для многопоточного программирования: тут есть и различного вида локи, и семафор, и механизм событий. Один словом — все, что нужно для подавляющего большинства многопоточных программ.
\begin{itemize}
\item Существуют две самые распространенные причины использовать потоки: во-первых, для увеличения эффективности использования многоядерной архитектуры cоврменных процессоров, а значит, и производительности программы;
во-вторых, если нам нужно разделить логику работы программы на параллельные полностью или частично асинхронные секции (например, иметь возможность пинговать несколько серверов одновременно).
\item Мы сталкиваемся с таким ограничением Python (а точнее основной его реализации CPython), как Global Interpreter Lock (или сокращенно GIL). Концепция GIL заключается в том, что в каждый момент времени только один поток может исполняться процессором. Это сделано для того, чтобы между потоками не было борьбы за отдельные переменные. Исполняемый поток получает доступ по всему окружению. Такая особенность реализации потоков в Python значительно упрощает работу с потоками и дает определенную потокобезопасность (thread safety).
\item Чем больше потоков - тем больше программа исполняется! Т.е. 1 поток делающий 999 операций выполнится быстрее чем 3 потока делающие "параллельно" по 333 операции.
\end{itemize}

Для того, чтобы в некотором смысле решить проблему п.3, в Python есть модуль subprocess. Мы можем написать программу, которую хотим исполнять в параллельном потоке (на самом деле уже процессе). И запускать ее в одном или нескольких потоках в другой программе. Такой способ действительно ускорил бы работу нашей программы, потому, что потоки, созданные в запускающей программе GIL не забирают, а только ждут завершения запущенного процесса. Однако, в этом способе есть масса проблем. Основная проблема заключается в том, что передавать данные между процессами становится трудно. Пришлось бы как-то сериализовать объекты, налаживать связь через PIPE или друге инструменты, а ведь все это несет неизбежно накладные расходы и код становится сложным для понимания.
В Python есть модуль multiprocessing. По функциональности этот модуль напоминает threading. Например, процессы можно создавать точно так же из обычных функций. Методы работы с процессами почти все те же самые, что и для потоков из модуля threading. А вот для синхронизации процессов и обмена данными принято использовать другие инструменты. Речь идет об очередях (Queue) и каналах (Pipe). Впрочем, аналоги локов, событий и семафоров, которые были в threading, здесь тоже есть.
Кроме того в модуле multiprocessing есть механизм работы с общей памятью. Для этого в модуле есть классы переменной (Value) и массива (Array), которые можно “обобщать” (share) между процессами. Для удобства работы с общими переменными можно использовать классы-менеджеры (Manager). Они более гибкие и удобные в обращении, однако более медленные. Нельзя не отметить приятную возможность делать общими типы из модуля ctypes с помощью модуля multiprocessing.sharedctypes.

Еще в модуле multiprocessing есть механизм создания пулов процессов. Этот механизм очень удобно использовать для реализации шаблона Master-Worker или для реализации параллельного Map (который в некотором смысле является частным случаем Master-Worker).

\subsection{asinc и await}

asinc и await

		async, await - определения сопрограмм с помощью ключевых слов.
	
	Главное, наверное, это то, что теперь сопрограмма в Python — это специальный объект native coroutine, а не каким-то специальным образом оформленный генератор или еще что-то. Этот объект имеет методы и функции стандартной библиотеки для работы с ним. То есть теперь, это объект, определяемый как часть языка. 
	Ключевое слово await указывает, что при выполнении следующего за ним выражения возможно переключение с текущей сопрограммы на другую или на основной поток выполнения.
	
	Соответственно выражение после await тоже не простое, это должен быть awaitable объект:

		\begin{itemize}
		\item Другая сопрограмма, а именно объект native coroutine. Этот напоминает, и видимо реализовано аналогично случаю, когда в генераторе с помощью yield from вызывается другой генератор.
		\item Сопрограмма на основе генератора, созданная с помощью декоратора types.coroutine(). Это вариант обеспечения совместимости с наработками, где сопрограммы реализованы на основе генераторов.
		\item Специальный объект, у которого реализован магический метод \pyth{__await__}, возвращающий итератор. С помощью этого итератора реализуется возврат результата выполнения сопрограммы.
	\end{itemize}
	
	\begin{itemize}
		\item async def — определяет native coroutine function, результатом вызова которой будет объект-сопрограмма native coroutine, пока еще не запущенная.
		\item async for — определяет, что итератор используемый в цикле, при получении следующего значения может переключать выполнение с текущей сопрограммы. Объект итератор имеет вместо стандартных магических методов: \pyth{__iter__} и \pyth{__next__}, методы: \pyth{__aiter__} и \pyth{__anext__}. Функционально они аналогичны, но как следует из определения, допускают использования await в своем теле.
		\item async with — определяет, что при входе в контекстный блок и выходе из него может быть переключение выполнения с текущей сопрограммы. Так же, как и в случае с асинхронным генератором, вместо магических методов: \pyth{__enter__} и \pyth{__exit__} следует использовать функционально аналогичные \pyth{__aenter__} и \pyth{__aexit__}.
	\end{itemize}
	
\section{Отличия python 2.x и 3.x}

\subsection{New style и old style классы}

New style и old style классы, что такое когда появились, где используются

До питон 2.1 пользователю были доступны только классы старого стиля. Если х - это экземпляр класса, то \pyth{x.__class__} обозначает класс x. Но \pyth{tupe(x)} всегда <type 'instance'>. Это отражает тот факт, что все экземпляры старого стиля, независимо от их класса, реализуются с помощью одного встроенного типа, называемый экземпляр.
Классы нового стиля были введены в Python 2.2, чтобы объединить понятия класса и типа. Класс нового стиля - это просто определенный пользователем тип. И при этом \pyth{x.__class__ == type(x)}
Из соображений совместимости, классы по-прежнему имеют старый стиль по умолчанию до python 3. В Python [3:].* - упразднены. 

\section{Протоколы}

\subsection{Протокол итератора}

Для реализации протокола необходимо реализовать 3 условия:
\begin{itemize}
    \item Метод \pyth{__iter__()} - для получения экземпляра итератора;
    \item \pyth{__next__()} - для получения следующего элемента последовательности;
    \item Вызов исключения \pyth{raise StopIteration} когда итерация закончена. 
\end{itemize}

Для получения итератора применяется функция iter(), она действует так:
\begin{enumerate}
    \item Проверяет, реализует ли объект метод \pyth{__iter__()}; 
    \item Если нет, реализует ли он \pyth{__getitem__()}. Если да, то python создает итератор, который передает туда индексы начиная с 0;
    \item Вызывает исключение - объект не интерируемые.
\end{enumerate}

\subsubsection{Итераторы}

Итератор - это объект абстракция, который способен получать из последовательности данных элемент за элементом. Является шаблоном проектирования.

Объекты, которые реализуют функцию \pyth{__iter__()}, возвращающий итератор называются итерируемыми. 

Последовательность всегда итерируема, т.к. это объекты реализующие метод \pyth{__getitem__()}, которые принимает индексы начинающиеся с 0.

\subsubsection{Итерация}

Итерируемый объект - любой объект, от которого функция iter() может получить итератор. 
Итерация - процесс последовательного считывания последовательности элементов из контейнера. Последовательность считывается с помощью итератора, который автоматически создает цикл for.
Python получает итераторы от итерируемых объетов.

\subsubsection{Генераторы, yield}

Генератор - это объект, который хранит текущее состояние для вычисления нового значения, с помощью ключевого слова yield, это синтетический сахар, упрощенный итератор. Любой генератор является итератором, т.к. полностью реализует его интерфейс.

\begin{python}
def my_generator(count):
    for i in range(count):
        yield print(i)

t = my_generator(3)

next(t) # 0
next(t) # 1
next(t) # 2
next(t) # StopIteration

\end{python}

\subsubsection{Состояние генератора}

Узнать состояние генератора позволяет функция inspect.getgeneratorstate().
Генератор может быть в нескольких состояниях:
\begin{enumerate}
    \item GEN\_CREATED - создан и ожидает выполнения;
    \item GEN\_RUNNGING - выполняется интепретатором;
    \item GEN\_SUSPENDED - присотановлен в слове yield;
    \item GEN\_CLOSED - завершен.
\end{enumerate}

\subsubsection{Цепочки итераторов}

Мощное средство для обработки данных на конвеере.

\begin{python}
counter = 5

def my_generator(count):
    for i in range(1, count):
        yield i

def squared(seq):
    for i in seq:
        yield i*i

print(list(my_generator(counter))) # [1, 2, 3, 4]
print(list(squared(my_generator(counter)))) # [1, 4, 9, 16]

\end{python}


\subsubsection{Делигирующие генераторы}

\subsection{Протокол менеджера контектста}

\subsubsection{Менеджер контекста}		

Менеджер контекста. Что это такое, зачем, для чего применяются, чем можно заменить. 

		Контекстные менеджеры это специальные конструкции, которые представляют из себя блоки кода, заключенные в инструкцию with. Из этого следует, что контекстный менеджер используется для выполнения каких либо действий до входа в блок и после выхода из него.  Применяется для гарантии того, что критические функции выполнятся в любом случае. Самый распространённый пример использования этой конструкции - открытие файлов. Аналог - открытии файлов с помощью функции open, однако конструкция with ... as, как правило, является более удобной и гарантирует закрытие файла в любом случае.
	
	Общий вид: Конструкция with ... as используется для оборачивания выполнения блока инструкций менеджером контекста. Иногда это более удобная конструкция, чем try...except...finally.
	\begin{python}
	"with" expression ["as" target] ("," expression ["as" target])* ":"
	    suite
	\end{python}
	
	Теперь по порядку о том, что происходит при выполнении данного блока:
	\begin{itemize}
		\item Выполняется выражение в конструкции with ... as.
		\item Загружается специальный метод \pyth{__exit__} для дальнейшего использования.
		\item Выполняется метод \pyth{__enter__}. Если конструкция with включает в себя слово as, то возвращаемое методом \pyth{__enter__} значение записывается в переменную.
		\item Выполняется suite.
		\item Вызывается метод \pyth{__exit__}, причём неважно, выполнилось ли suite или произошло исключение. В этот метод передаются параметры исключения, если оно произошло, или во всех аргументах значение None, если исключения не было.
	\end{itemize}
	
	Пример собственного контекстного менеджера:
	\begin{python}
			class Hello:
	   ...:     def __del__(self):
	   ...:         print u'destructor'
	   ...:     def __enter__(self):
	   ...:         print u'enter to block'
	   ...:     def __exit__(self, exp_type, exp_value, traceback):
	   ...:         print u'exit from block'
	\end{python}

\subsection{Протокол дескриптора}	

Грубо говоря, это объект для которого определены:
\pyth{descr.__get__(self, obj, type=None)} --> value
\pyth{descr.__set__(self, obj, value)} --> None
\pyth{descr.__delete__(self, obj)} --> None
Какие бывают дескрипторы в Python'не?
Всего в языке есть два типа дескрипторов:
\begin{itemize}
	\item Данных (data descriptor)
	\item Не-Данных (непереводимое название, правда. Звучит в оригинале как non-data descriptor)
\end{itemize}


Пример data дескриптора, который присваивает и возвращает значение переменной, а также печатает историю доступа к переменной.

	\begin{python}
class RevealAccess(object):

    def __init__(self, initval=None, name='var'):
        self.val = initval
        self.name = name

    def __get__(self, obj, objtype):
        print 'get value', self.name
        return self.val

    def __set__(self, obj, val):
        print 'set value' , self.name
        self.val = val

>>> class MyClass(object):
    x = RevealAccess(10, 'var "x"')
    y = 5

>>> m = MyClass()
>>> m.x
get value "x"
10
>>> m.x = 20
set value "x"
>>> m.x
get value "x"
20
>>> m.y
5
\end{python}

\subsubsection{Переопределение оператора . для доступа}

Для переопределния чтения атрибута класса существует 2 метода: 
\begin{itemize}
    \item \pyth{__getattr__()} - действует если не сработал обычный механизм доступа;
    \item \pyth{__getattribute__()} - действует всегда, даже если запрашиваемый атрибут существует.
\end{itemize}


\section{Метаклассы, функция type}

	
	Перед тем, как изучать метаклассы, надо хорошо разобраться с классами, а классы в Питоне — вещь весьма специфическая (основаны на идеях из языка Smalltalk).

В большинстве языков класс это просто кусок кода, описывающий, как создать объект. В целом это верно и для Питона:
\begin{python}
  >>> class ObjectCreator(object):
  ...       pass
  ... 

  >>> my_object = ObjectCreator()
  >>> print my_object
  <__main__.ObjectCreator object at 0x8974f2c>
  \end{python}

Но в Питоне класс это нечто большее — классы также являются объектами.

Как только используется ключевое слово class, Питон исполняет команду и создаёт объект. Инструкция
\begin{python}
  >>> class ObjectCreator(object):
  ...       pass
  ...
  \end{python}

создаст в памяти объект с именем ObjectCreator.

Этот объект (класс) сам может создавать объекты (экземпляры), поэтому он и является классом.

Тем не менее, это объект, а потому:
\begin{itemize}
	\item	его можно присвоить переменной,
	\item	его можно скопировать,
	\item	можно добавить к нему атрибут,
	\item	его можно передать функции в качестве аргумента.
\end{itemize}

Метакласс это «штука», которая создаёт классы.

Мы создаём класс для того, чтобы создавать объекты, так? А классы являются объектами. Метакласс это то, что создаёт эти самые объекты. Они являются классами классов, можно представить это себе следующим образом:
\begin{python}
  MyClass = MetaClass()
  MyObject = MyClass()
\end{python}

Мы уже видели, что type позволяет делать что-то в таком духе:
\begin{python}
  MyClass = type('MyClass', (), {})
\end{python}

Это потому что функция type на самом деле является метаклассом. type это метакласс, который Питон внутренне использует для создания всех классов.
	
		Функция type для чего еще и как создавать метаклассы
		
		\textit{Метакласс} — это объект, умеющий управлять созданием классов. Или динамическое создание классов.
		Создание классов:
		
		\begin{itemize}
		\item \pyth{type('A', baseclasses, attributes)}
		У потомков type есть одна особенность, требующая особого внимания; на ней спотыкаются все, кто первый раз работает с метаклассами. Первый аргумента этих методов обычно называется cls, а не self, потому что методы работают с созданным классом, а не с метаклассом. 
		\item 
		\begin{python}
			>>> class Printable(type):
			...     def whoami(cls): print "I am a", cls.__name__
			...
			>>> Foo = Printable('Foo')
			>>> Foo.whoami()
			I am a Foo
			>>> Printable.whoami()
			Traceback (most recent call last):
			TypeError:  unbound method whoami() [...]
			
			>>> class Bar:
			...     __metaclass__ = Printable
			...     def foomethod(self): print 'foo'
			...
			>>> Bar.whoami()
			I am a Bar
			>>> Bar().foomethod()
			foo	
		\end{python}
	\end{itemize}
